toolName: todo_write
            
status: success
          
Todos updated: 1 items
          

        
            
toolName: todo_write
            
status: success
          
Todos updated: 1 items
          
**Slide 1（1:30）标题：Agent Skills：把“我们的方法”装进可复用的能力包**
- 我们要解决的问题：重复讲需求、上下文浪费、流程不一致
- Skills 的定位：教会 agent “怎么做”，而不是“去哪里拿数据”
- 核心关键词：可移植、可组合、按需加载
- 今天的目标：讲清楚架构、边界、落地与评估
- 听完你应该能：判断什么时候该写 Skill、怎么写、怎么测

讲稿（逐字稿）：
大家好，今天我讲的不是“模型有多强”，而是“怎么把我们团队的工作方式变成可复用的工程资产”。我们在日常用 agent 时，最痛的是三件事：第一，每次都要重新讲一遍需求和口径；第二，上下文越堆越长，成本失控还容易跑偏；第三，同一个任务多跑几次，输出结构和风格漂移，难以交付。Skills 的核心定位是：把“遇到某类任务应该怎么做”固化成一个可发现、可按需加载、可组合的能力包，让通用 agent 以更低的上下文成本，稳定地产出一致结果。接下来我会从架构开始讲，然后讲它和 Tools、MCP、Subagents 的边界，最后给出硬核落地与评估方法。

---

**Slide 2（2:00）标题：没有 Skills：成本与可靠性如何失控**
- 每次重述：指令、模板、参考资料、边界条件
- 上下文污染：信息堆叠导致召回不稳定
- 一致性缺失：同类任务输出结构漂移
- 可维护性差：个人 prompt 知识孤岛，无法治理
- 结果：高 token 成本 + 低交付确定性

讲稿（逐字稿）：
先把问题讲透。没有 Skills 的时候，我们通常靠两种方式：第一，写一个很长的提示词；第二，把各种资料复制粘贴进对话。结果是上下文越来越脏：不相关的内容混进去，关键规则被稀释，模型“有时记得，有时忘了”。更糟的是团队协作：每个人都有自己的 prompt 版本，规则分散在聊天记录里，无法评审、无法回归、无法版本化。你会发现我们花了很多 token 在“搬运上下文”，却得不到工程上想要的确定性。Skills 的价值就在于：把知识与流程模块化，按需加载，把确定性任务交给脚本，把一致性变成可治理的资产。

---

**Slide 3（2:00）标题：Skills 是什么：轻量、开放、可扩展的能力单元**
- Skill 本质：一个文件夹组织的“指令 + 资源 + 脚本”
- 解决三类需求：领域 expertise、可重复 workflow、新能力封装
- 关键属性：可移植（跨兼容 agent）、可组合（拼工作流）
- 运行方式：按需加载指令，按需读取/执行资源
- 目标：用工程化方式提升稳定性与复用

讲稿（逐字稿）：
给一个严格定义：Skill 是一个轻量、开放格式的能力单元，通常就是一个目录，里面包含指令、脚本、模板和参考资料。它不是“更长的 prompt”，而是把过程化知识外置到文件系统里，让 agent 在需要时加载。Skills 能覆盖三类价值：第一，领域 expertise，比如品牌规范、法律流程、指标口径；第二，可重复 workflow，比如周报流程、季度复盘流程；第三，新能力封装，比如生成报表、做格式转换、自动化校验。它的两个工程属性很关键：可移植，意味着你在一个环境写的 Skill 能跨不同兼容 agent 复用；可组合，意味着你可以把多个 Skill 串成完整 pipeline。

---

**Slide 4（2:00）标题：范式转变：专用 Agent → 通用 Agent + Skills**
- 旧思路：为每个角色造专用 agent，脚手架与提示各自维护
- 新思路：通用 agent 以“代码/文件系统”为统一接口
- Skills 提供：团队/公司特定方法论与流程，按需注入
- 好处：降低维护面、提升一致性、支持规模化扩展
- 结果：从“提示工程”转向“上下文工程”

讲稿（逐字稿）：
过去我们直觉是：研究就用研究 agent，营销就用营销 agent，每个都有自己的提示词体系和工具链。这样看似专业，实际维护成本极高：每个专用 agent 都有一套重复的脚手架和规则，升级难、共享难、治理难。新的范式更像软件工程：用一个通用 agent 作为执行引擎，交互接口尽量简单，主要依赖文件系统与脚本执行；再通过 Skills，把不同领域的做事方法按需注入。注意，这里不是“prompt 变多了”，而是“知识被模块化并按需加载”，这是上下文工程的核心：控制上下文成本，控制污染，控制一致性。

---

**Slide 5（3:00）标题：核心架构：Progressive Disclosure（三层渐进式加载）**
- Level 1 Metadata：启动时常驻，低成本用于发现与路由（约 ~100 tokens/skill）
- Level 2 Instructions：命中任务时加载，提供具体工作法（建议 <5k tokens）
- Level 3 Resources：执行时按需读取/运行（文件内容不直接进入上下文）
- 关键收益：减少 token 消耗、避免无关信息污染
- 工程含义：把“知识”与“执行”拆开，让输出更可控

讲稿（逐字稿）：
这是 Skills 最硬核的技术点：渐进式加载，或者叫 Progressive Disclosure。它把一个 Skill 的内容拆成三层，分别在不同时间加载。第一层 Metadata 常驻，成本很低，主要用于“让系统知道有哪些 Skill，以及何时可能相关”。第二层 Instructions 只有在请求匹配时才加载，也就是“真正需要时才把工作法放进上下文”。第三层 Resources 更关键：详细参考、模板、脚本都放在文件系统里，只有当我们真的要执行某一步时才去读取或运行，而且注意——文件本身不直接进入上下文，进入上下文的是读取/执行后的输出。这就是为什么它能同时做到可扩展和低污染：你可以有很多 Skill，但不会把上下文窗口塞爆。

---

**Slide 6（1:30）标题：Skill 的最小结构：SKILL.md = 元数据 + 指令正文**
- YAML Frontmatter：name、description（必填），用于发现与触发
- Markdown 正文：工作流、输入输出、示例、边界情况
- 可选目录：/references、/scripts、/assets（承载资源层）
- 经验法则：正文保持精炼，复杂内容外置到 resources
- 目标：让 agent “能找到、能理解、能执行”

讲稿（逐字稿）：
落到文件结构，Skill 的最小单元就是一个 SKILL.md，它由两部分组成：顶部是 YAML Frontmatter，至少要有 name 和 description；这部分负责让 agent 能发现这个 Skill、并判断何时该加载。下面是 Markdown 正文，写清楚工作流、输入输出、示例和边界情况。更详细的内容不要塞在正文里，而是放到 resources：比如 references 放扩展文档，scripts 放可执行脚本，assets 放模板和图片。这里的工程目标只有三个：能找到、能理解、能执行。

---

**Slide 7（2:30）标题：编写规范：让 Skill “可检索、可治理、可复用”**
- name：≤64；小写字母/数字/连字符；不以连字符开头结尾；与父目录同名；推荐 -ing
- description：≤1024；不能为空；写清“做什么/何时用”，包含触发关键词
- 正文建议：控制在 500 行内；复杂内容拆到 references
- 目录建议：references 尽量只比 SKILL.md 深一层，避免深嵌套
- 路径统一：使用正斜杠（跨平台一致）

讲稿（逐字稿）：
如果你希望 Skill 在团队里“可用、可控”，这页就是硬门槛。name 有严格约束：长度、字符集、连字符位置、并且要和父目录同名，推荐用动名词形式 -ing，这些约束不是形式主义，是为了规模化治理。description 更重要：它不是一句泛泛的介绍，而是触发与路由的重要信号，必须写清楚做什么、什么时候用，并包含能被识别的关键词。正文也要控制规模，建议在 500 行以内；一旦变大，就把细节拆到 references。你会发现这些规则和我们写库、写 API 文档的原则一样：可发现、可维护、可版本化。

---

**Slide 8（2:00）标题：Degrees of Freedom：用“自由度”控制可靠性**
- 高自由度：给方向，适合创意与探索型输出
- 中自由度：给模式/伪代码/示例，允许小范围变化
- 低自由度：引用脚本与固定顺序，强约束、最稳定
- 选型原则：关键路径低自由度，非关键路径提高自由度
- 目标：在“通用性”和“确定性”之间可控权衡

讲稿（逐字稿）：
Skills 落地最常见的失败，是自由度没设计好：要么写得很松，结果不稳定；要么写得太死，复用性差。材料里把自由度分成三个档：高自由度只给方向，适合创意任务；中自由度给模式和示例，允许一定变化；低自由度直接指定脚本与执行顺序，最稳定。我的建议很明确：把“交付必须正确”的关键路径做成低自由度，脚本化、顺序化；把“可以多样化”的部分留给高自由度。你不是在写一段话，你是在设计一个可控系统。

---

**Slide 9（2:00）标题：执行环境与安全边界：为什么 Skills 更工程化**
- 运行介质：文件系统读写 + 脚本执行（确定性更强）
- 安全限制：无网络访问
- 依赖限制：不能运行时安装包（只用预装能力）
- 资源限制：CPU/内存受限（鼓励可复现、可控流程）
- 结论：把复杂逻辑放脚本，把上下文留给决策与总结

讲稿（逐字稿）：
硬核同学通常会问：这套东西在什么环境里跑，边界是什么？材料给的答案很明确：Skills 依赖文件系统读写和脚本执行来完成确定性任务；安全上没有网络访问；依赖上不能运行时安装包；资源上 CPU 和内存有限。听起来限制很多，但工程上这是好事：它逼迫我们把流程设计得可复现、可控。最关键的实践结论是：把复杂、可计算、可校验的部分放到脚本里做，把上下文留给需要语义理解的部分，比如目标拆解、结果解释与取舍。

---

**Slide 10（2:00）标题：可组合：从单技能到端到端工作流**
- Skill 之间可组合：品牌规范 Skill + PPT Skill + 数据分析 Skill
- 协作方式：共享文件作为中间产物，而不是塞进对话
- 编排逻辑：agent 根据任务自动决定加载与执行顺序
- 典型场景：数据分析 → 产出图表 → 生成汇报稿/幻灯片
- 优势：模块化复用、职责清晰、可替换可升级

讲稿（逐字稿）：
单个 Skill 像一个库函数；多个 Skill 组合起来就是 pipeline。比如做一次季度业务复盘：一个 Skill 负责定义口径与方法，一个 Skill 负责把数据产出成图表，一个 Skill 负责把图表与要点组织成 PPT。关键在于中间产物的传递方式：不要把大段数据和图表塞进对话，而是落到文件里，再按需读取。这同时解决了上下文成本和可复现性：文件可保存、可检查、可复跑。模块化带来的收益也很直接：任意一个环节都可以替换、升级，而不影响整体结构。

---

**Slide 11（2:00）标题：边界 1：Skills vs Tools**
- Tools：固定能力集合，工具定义常驻上下文
- Skills：按需加载的知识与流程，用于“教怎么做”
- 区分点：Tool 是能力接口；Skill 是过程与标准
- “tools on demand”：Skill 可携带 scripts，把能力封装成资源
- 结论：Tool 提供手脚；Skill 提供方法与规范

讲稿（逐字稿）：
很多人会混淆 Skills 和 Tools。Tools 更像系统调用：能力是固定的，并且工具定义通常常驻在上下文里；它解决的是“我能做什么操作”。Skills 解决的是“面对某类任务应该怎么做”，它按需加载，强调流程、标准、边界条件。更进一步，Skills 还能携带 scripts，这相当于把某些能力做成“随用随取”的可执行资源。我的总结是：Tools 给你手脚，Skills 给你方法论和团队规范。两者不是替代关系，而是分层协作。

---

**Slide 12（2:00）标题：边界 2：Skills vs MCP**
- MCP：连接外部系统与数据（数据库/API/服务）= access
- Skills：定义如何使用数据计算指标与决策 = expertise
- 单用 MCP 的问题：有数据没口径、没流程、没一致性
- 单用 Skills 的问题：有方法没数据、无法闭环
- 最佳组合：MCP 拉数据 → Skill 定义方法 → scripts 计算/验证

讲稿（逐字稿）：
再讲 MCP。材料里一句话非常准确：MCP 提供 access，Skills 提供 expertise。MCP 的职责是把 agent 接到外部系统和数据上，比如数据库、API、服务；但它不会告诉你“该怎么算指标、该用哪些列、该怎么校验”。如果你只上 MCP，你会得到“可访问但不可交付”的系统：每个人算出来的口径不一致。反过来只上 Skills，你有方法却没有数据，无法闭环。正确的工程组合是：MCP 把数据拉进来，Skills 定义口径与流程，脚本负责计算与验证，把不确定性压到最小。

---

**Slide 13（1:30）标题：边界 3：Skills vs Subagents**
- Subagent：独立上下文与权限，用于并行与隔离
- Skills：可增强主 agent 与所有 subagents 的工作法
- 组合方式：主 agent 负责编排；subagents 按同一套 Skills 执行
- 风险提示：并行不等于一致性，规范必须共享
- 结论：Subagents 是组织形态；Skills 是知识与流程资产

讲稿（逐字稿）：
Subagents 是另一条常见路线：把任务拆给多个子 agent 并行处理。它的价值是并行与隔离：每个 subagent 有自己的上下文和权限边界。但要注意，Subagents 本身不保证一致性。你如果不给他们共享的流程与标准，他们会并行地产生不一致的答案。Skills 的角色正是在这里体现：它可以增强主 agent，也可以增强所有 subagents，让他们基于同一套口径与流程执行。总结就是：Subagents 是组织形态，Skills 是知识与流程资产，两者组合才能既快又稳。

---

**Slide 14（2:30）标题：评估与质量：让 Skill 可测、可回归、可上线**
- 单元测试结构：skills / queries / files / expected_behavior
- 期望行为要可判定：能读输入、提取目标、按模板输出、产物可编译/可执行
- 覆盖策略：覆盖常见输入类型与边界情况
- 质量闭环：人工反馈 + 回归样例集 + 多模型测试
- 目标：从 demo 走向可治理的生产资产

讲稿（逐字稿）：
硬核团队最终看的不是“演示效果”，而是“可测性与可治理”。材料里给了一个很清晰的评估框架：测试用例要定义四件事——测哪些 skills，用哪些 queries，使用哪些输入 files，以及 expected_behavior 是什么。注意 expected_behavior 必须可判定：比如是否成功读取并提取输入、是否提取出所有目标、是否遵循输出模板、LaTeX 是否能编译、脚本是否成功执行。然后把这些变成回归样例集，结合人工反馈，再覆盖你计划使用的所有模型。只有这样，Skill 才能像代码一样被版本化、被评审、被回归，最终可上线。

---

**Slide 15（1:30）标题：落地路线图 + Takeaways**
- 先选 3 类高 ROI 任务：高频、强模板、强口径、可验证
- 自由度策略：关键路径低自由度（脚本化），创意路径高自由度
- 建立治理：命名规范、评审门槛、测试与版本管理
- Takeaway 1：Progressive Disclosure 是上下文工程的关键
- Takeaway 2：MCP=access，Skills=expertise；组合才能闭环

讲稿（逐字稿）：
最后给一个可执行的落地路线图。第一步不要贪大，先选三类 ROI 最高的任务：高频、强模板、强口径、并且结果可验证——比如报表生成、标准化复盘、固定口径的数据分析。第二步设计自由度：把关键交付路径脚本化、顺序化，走低自由度；创意表达部分留高自由度。第三步做工程治理：命名规范、评审门槛、测试与版本管理，像管理代码一样管理 Skills。两句 takeaways：第一，渐进式加载是上下文工程的核心，直接决定成本与可靠性；第二，MCP 解决 access，Skills 解决 expertise，组合起来才是可交付的系统。接下来我们可以围绕成本、可靠性、治理三类问题直接开问。